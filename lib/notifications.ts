import { prisma } from '@/lib/prisma'
import { logError } from '@/lib/utils/logger'

export interface CreateNotificationData {
  userId: string
  title: string
  message: string
  type: 'info' | 'success' | 'warning' | 'error'
}

export async function createNotification(data: CreateNotificationData) {
  try {
    return await prisma.notification.create({
      data: {
        userId: data.userId,
        title: data.title,
        message: data.message,
        type: data.type
      }
    })
  } catch (error) {
    logError(error, { context: 'createNotification', userId: data.userId })
    throw error
  }
}

export async function createBulkNotifications(notifications: CreateNotificationData[]) {
  try {
    return await prisma.notification.createMany({
      data: notifications
    })
  } catch (error) {
    logError(error, { context: 'createBulkNotifications', count: notifications.length })
    throw error
  }
}

// Notification templates for common events
export const NotificationTemplates = {
  taskAssigned: (taskTitle: string, assigneeName: string) => ({
    title: 'New Task Assigned',
    message: `You have been assigned a new task: "${taskTitle}"`,
    type: 'info' as const
  }),

  taskCompleted: (taskTitle: string, assigneeName: string) => ({
    title: 'Task Completed',
    message: `Task "${taskTitle}" has been completed by ${assigneeName}`,
    type: 'success' as const
  }),

  taskStatusChanged: (taskTitle: string, newStatus: string, assigneeName: string) => ({
    title: 'Task Status Updated',
    message: `Task "${taskTitle}" status changed to ${newStatus} by ${assigneeName}`,
    type: 'info' as const
  }),

  attendanceCheckedIn: (employeeName: string, time: string) => ({
    title: 'Check-in Recorded',
    message: `${employeeName} checked in at ${time}`,
    type: 'success' as const
  }),

  attendanceCheckedOut: (employeeName: string, time: string) => ({
    title: 'Check-out Recorded',
    message: `${employeeName} checked out at ${time}`,
    type: 'success' as const
  }),

  attendanceLate: (employeeName: string, time: string, lateMinutes?: number) => ({
    title: 'Late Arrival',
    message: `${employeeName} arrived late at ${time}${lateMinutes ? ` (${lateMinutes} minutes late)` : ''}`,
    type: 'warning' as const
  }),

  attendanceEarly: (employeeName: string, time: string, earlyMinutes?: number) => ({
    title: 'Early Departure',
    message: `${employeeName} checked out early at ${time}${earlyMinutes ? ` (${earlyMinutes} minutes early)` : ''}`,
    type: 'warning' as const
  }),

  newEmployeeAdded: (employeeName: string, department: string) => ({
    title: 'New Employee Added',
    message: `${employeeName} has been added to ${department} department`,
    type: 'info' as const
  }),

  employeeUpdated: (employeeName: string, changes: string[]) => ({
    title: 'Employee Updated',
    message: `${employeeName}'s ${changes.join(', ')} has been updated`,
    type: 'info' as const
  }),

  taskDueSoon: (taskTitle: string, dueDate: string) => ({
    title: 'Task Due Soon',
    message: `Task "${taskTitle}" is due on ${dueDate}`,
    type: 'warning' as const
  }),

  taskOverdue: (taskTitle: string, dueDate: string) => ({
    title: 'Task Overdue',
    message: `Task "${taskTitle}" is overdue since ${dueDate}`,
    type: 'error' as const
  }),

  reportGenerated: (reportType: string, generatedBy: string) => ({
    title: 'Report Generated',
    message: `${reportType} report has been generated by ${generatedBy}`,
    type: 'info' as const
  })
}

// Helper function to get all managers and admins for notifications
export async function getManagersAndAdmins() {
  try {
    return await prisma.user.findMany({
      where: {
        role: {
          in: ['ADMIN', 'MANAGER']
        }
      },
      select: {
        id: true,
        name: true,
        role: true
      }
    })
  } catch (error) {
    logError(error, { context: 'getManagersAndAdmins' })
    return []
  }
}

/**
 * Get notification recipients for attendance events based on role-based access control
 * 
 * Business Logic:
 * - Employee check-in/out: Notify their manager (if exists) + all admins
 * - Manager check-in/out: Notify all admins + their manager (if exists)
 * - Admin check-in/out: Notify all admins (optional, can be removed if not needed)
 * 
 * @param employeeUserId - The user ID of the employee who checked in/out
 * @param employeeRole - The role of the employee (ADMIN, MANAGER, EMPLOYEE)
 * @returns Array of user IDs who should receive the notification
 */
export async function getAttendanceNotificationRecipients(
  employeeUserId: string,
  employeeRole: string
): Promise<string[]> {
  try {
    const recipients: string[] = []

    // Always notify all admins
    const admins = await prisma.user.findMany({
      where: {
        role: 'ADMIN'
      },
      select: {
        id: true
      }
    })
    recipients.push(...admins.map(admin => admin.id))

    // Get employee record to find manager
    const employee = await prisma.employee.findUnique({
      where: {
        userId: employeeUserId
      },
      include: {
        manager: {
          include: {
            user: {
              select: {
                id: true,
                role: true
              }
            }
          }
        }
      }
    })

    if (employee) {
      // Notify the employee's manager if they exist
      if (employee.manager?.user) {
        recipients.push(employee.manager.user.id)
      }

      // If the employee is a manager, also notify their direct manager (if exists)
      // This is handled by the manager relationship above
    }

    // Remove duplicates and the employee themselves (they get their own notification separately if needed)
    const uniqueRecipients = Array.from(new Set(recipients)).filter(id => id !== employeeUserId)

    return uniqueRecipients
  } catch (error) {
    logError(error, { context: 'getAttendanceNotificationRecipients', employeeUserId, employeeRole })
    // Fallback to all admins if error occurs
    const admins = await prisma.user.findMany({
      where: { role: 'ADMIN' },
      select: { id: true }
    })
    return admins.map(admin => admin.id)
  }
}

/**
 * Get all user IDs that should receive notifications for a specific employee's attendance
 * This includes managers of that employee and all admins
 * 
 * @param employeeUserId - The user ID of the employee
 * @returns Array of user IDs who should receive notifications
 */
export async function getNotificationRecipientsForEmployee(employeeUserId: string): Promise<string[]> {
  try {
    return await getAttendanceNotificationRecipients(employeeUserId, 'EMPLOYEE')
  } catch (error) {
    logError(error, { context: 'getNotificationRecipientsForEmployee', employeeUserId })
    return []
  }
}

// Helper function to get all employees in a department
export async function getEmployeesInDepartment(department: string) {
  try {
    return await prisma.employee.findMany({
      where: {
        department: department,
        isActive: true
      },
      include: {
        user: {
          select: {
            id: true,
            name: true
          }
        }
      }
    })
  } catch (error) {
    logError(error, { context: 'getEmployeesInDepartment', departmentId })
    return []
  }
}
