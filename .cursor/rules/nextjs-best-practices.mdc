---
alwaysApply: true
description: Next.js 15 best practices and project structure guidelines
---

# Next.js 15 Best Practices & Project Structure

## üèóÔ∏è Project Architecture

### App Router Structure
- Use App Router (`app/` directory) for all new pages
- Place API routes in `app/api/` directory
- Use `layout.tsx` for shared layouts
- Use `page.tsx` for route components
- Use `loading.tsx` for loading states
- Use `error.tsx` for error boundaries

### File Naming Conventions
- Use `kebab-case` for directories: `employee-management/`
- Use `PascalCase` for components: `EmployeeCard.tsx`
- Use `camelCase` for utilities: `formatDate.ts`
- Use `UPPER_CASE` for constants: `API_ENDPOINTS.ts`

## üîß Component Guidelines

### Server vs Client Components
- Default to Server Components for data fetching
- Use `"use client"` only when necessary (hooks, event handlers, browser APIs)
- Keep client components small and focused
- Use Server Actions for mutations

### Component Structure
```tsx
// ‚úÖ Good: Server Component with proper imports
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { getEmployees } from '@/lib/actions'

export default async function EmployeeList() {
  const employees = await getEmployees()
  
  return (
    <Card>
      <CardHeader>
        <CardTitle>Employees</CardTitle>
      </CardHeader>
      <CardContent>
        {/* Content */}
      </CardContent>
    </Card>
  )
}
```

### Client Component Pattern
```tsx
// ‚úÖ Good: Client Component with proper hooks
"use client"

import { useState, useEffect } from 'react'
import { Button } from '@/components/ui/button'

export function InteractiveComponent() {
  const [state, setState] = useState('')
  
  useEffect(() => {
    // Side effects
  }, [])
  
  return <Button onClick={() => setState('updated')}>Click me</Button>
}
```

## üóÑÔ∏è Database & API Patterns

### Prisma Usage
- Always use the singleton pattern for Prisma client: [lib/prisma.ts](mdc:lib/prisma.ts)
- Use Server Actions for mutations
- Implement proper error handling
- Use transactions for complex operations

### API Route Structure
```tsx
// ‚úÖ Good: API route with proper error handling
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export async function GET(request: NextRequest) {
  try {
    const data = await prisma.employee.findMany()
    return NextResponse.json(data)
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch employees' },
      { status: 500 }
    )
  }
}
```

## üé® UI Component Guidelines

### shadcn/ui Integration
- Use shadcn/ui components from [components/ui/](mdc:components/ui/)
- Extend components when needed, don't modify source
- Use proper TypeScript types
- Implement proper accessibility

### Component Composition
```tsx
// ‚úÖ Good: Composed components
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'

export function EmployeeCard({ employee }: { employee: Employee }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{employee.name}</CardTitle>
        <Badge variant="secondary">{employee.role}</Badge>
      </CardHeader>
      <CardContent>
        <Button variant="outline">View Details</Button>
      </CardContent>
    </Card>
  )
}
```

## üîê Authentication & Security

### NextAuth.js Patterns
- Use Server Actions for authentication
- Implement proper session handling
- Use middleware for route protection
- Validate user permissions

### Security Best Practices
- Always validate input data
- Use proper TypeScript types
- Implement CSRF protection
- Sanitize user inputs

## üì± Responsive Design

### Mobile-First Approach
- Use Tailwind CSS responsive prefixes
- Test on multiple screen sizes
- Implement proper touch targets
- Use semantic HTML

### Layout Patterns
```tsx
// ‚úÖ Good: Responsive layout
<div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
  <Card className="p-4">
    <h3 className="text-lg font-semibold">Title</h3>
    <p className="text-sm text-muted-foreground">Description</p>
  </Card>
</div>
```

## üöÄ Performance Optimization

### Code Splitting
- Use dynamic imports for heavy components
- Implement lazy loading
- Use React.memo for expensive components
- Optimize bundle size

### Data Fetching
- Use Server Components for initial data
- Implement proper caching strategies
- Use SWR or React Query for client-side data
- Minimize API calls

## üß™ Testing Guidelines

### Component Testing
- Test user interactions
- Mock external dependencies
- Test error states
- Use proper test utilities

### API Testing
- Test all endpoints
- Mock database operations
- Test error scenarios
- Validate response formats

## üìù Code Quality

### TypeScript Usage
- Use strict mode
- Define proper interfaces
- Avoid `any` type
- Use proper generics

### Error Handling
- Implement error boundaries
- Use proper error messages
- Log errors appropriately
- Provide user-friendly feedback

## üîÑ State Management

### Local State
- Use useState for simple state
- Use useReducer for complex state
- Keep state close to where it's used
- Avoid prop drilling

### Global State
- Use Context API for global state
- Implement proper providers
- Use custom hooks for state logic
- Consider Zustand for complex state

## üìä Monitoring & Analytics

### Error Tracking
- Implement error boundaries
- Use proper logging
- Monitor performance
- Track user interactions

### Performance Monitoring
- Measure Core Web Vitals
- Monitor bundle size
- Track loading times
- Optimize images